{
    "contents" : "makeDMData<-function(species='bkt', \n                     cohorts=c(1996,2014),\n                     studyYears = c(2000,2014),\n                     modelType = 'js',\n                     dbCredentials=\"~/wb_credentials.rds\", \n                     processedDir=\"~/process-data/data_store/processed_data\" \n){\n\n# species:    specify a species (one of 'ats','bkt','bnt')\n# cohorts:    specify the min and max cohort to include e.g., c(1996,2014)\n# studyYears: just cuts off samples not in the period of interest\n# modelType: currently set up for either 'js' or 'cjs'\n#  cjs cuts off anything prior to first observations whereas\n#  js includes everything back to studyYears[1]\n# dbCredentials: to construct link to the database\n# processedDir: directory to write to and that holds sampleNames for season definition \n\n##########################################################################\n# Things to be careful of\n# 1. Make sure all the samples that need to included in dMdata are in adjDates \n\n# 2. fill in yearSeasonListAnt for non-salmon samples\n# 3. if have any samples that were not attempted (propSampledATSWest ==0), update the df 'temp' before it gets rbind to sampleDateList\n# 4. Update new rivers (West and Shorey done) for propSampled when any sample was incomplete. This is just for ATS. need to ignorre or change for bkt\n# 4. When writing code, make sure to order on tagNumber and sampleNumber after a merge if the order matters (e.g. evalRows)\n#############################################################################\n\n#############################################################################\n# Major steps:\n#   pheno: raw data from access\n#     access query subsets on area = \"inside\" Or \"trib\" Or \"above\" Or \"below\", excludes antennas\n#     basic data prep, cleans up inconsistencies, etc.\n#     incoroprates adjDates from spreadsheet to line up sample nums among rivers\n#\n#   pheno2: [prepare to create long format]\n#     1st step, subset pheno based on species and river\n#     \n#   pheno2Long: [long format (augmented), one observation per row and one row\n#               per sample (gets subsetted later)\n#\n#   dMData: long format, in addition to other subsetting, dMData only contains\n#           available == 1 rows (truncated for fish that are too old - determined\n#           by subsetDMdataAgeInSamples [ or fish that have emigrated permanently - no more like this ].\n#           All environmental data get merged into dMData as well. Data for P are\n#           on the occasion and data for phi and growth are over the interval.\n#           Missing observations have either data from the average day during the\n#           occ for P or data averaged (etc) over the median date interval.  \n#\n#############################################################################\n\n#############################################################################\n#   Metadata for objects saved in the .RData output file\n\n# \"evalJSRows\"          rows in dMData to evaluate when estimating phi in JS context. from ageInSamples==1 to subsetDMdataAgeInSamples     \n# \"evalRows\"            rows in dMData to evaluate when estimating phi in CJS context. from first to subsetDMdataAgeInSamples    \n# \"firstObsRows\"        rows in dMData that represent the first observation for each fish\n# \"lastObsRows\"         rows in dMData that represent the last observation for each fish\n\n# \"nEvalJSRows\"         number of rows in evalJSRows\n# \"nEvalRows\"           number of rows in evalRows\n# \"nFirstObsRows\"       number of rows in firstObsRows\n# \"nLastObsRows\"        number of rows in lastObsRows\n\n# \"nonSummerObsRows\"    rows in dMData that are not summer occasions (used for estimating p(maturation)\n# \"nNonSummerObsRows\"   number of rows in nonSummerObsRows\n# \"nonSummerAIS\"        ageInSample values that are not summer occasions\n# \"nSummerObsRows\"      number of rows in nonSummerAIS\n# \"summerAIS\"           ageInSample values that are summer occasions\n# \"summerObsRows\"       number of rows in summerAIS\n\n# \"dMData\"              This is the core data input file. it is vectorized so that each row represents a potential fish observation\n#                       Around the actual observation occasoins for each fish, it is augmented backwards to ageInSamples == 1\n#                       and forward to subsetDMdataAgeInSamples\n\n# variables in dMData\n\n# $ tagNumber             : Factor: PIT tag number\n# $ ageInSamples          : num: increments by one for each combination of season and age. 1 = season 3 (Fall), age 0  \n# $ year                  : num:  year of sample occasion\n# $ season                : Factor: season of sample occasion. 1=spring, 2=summer, 3=fall, 4=winter \n# $ sampleNum             : num:  sample number occasion. Scaled to start with 1 for first occasion in subset of data in dMData. \n#                                 May not match original sample numbers. yearSeasonList2 for original \n#                                (for WB, adjusted for other rivers-see adjSampNums.csv) sample # (sampleNumAdj) and new sample # sampleNumAdjConsec\n# $ drainage              : Factor: in pheno, \"CATAMARAN\" \"SAWMILL\"   \"SHOREY\"    \"WEST\"\n# $ river                 : Factor: in pheno, \"CATAMARAN BROOK\" \"SAWMILL RIVER\" \"SHOREY BROOK\" \"WB JIMMY\" \"WB MITCHELL\" \"WB OBEAR\"  \"WEST BROOK\" \n# $ date2                 : POSIXct: date of capture if captured\n# $ length                : int: fork lenght in mm  \n# $ mature01              : num: numeric indicator of male parr maturation (0=not observed mature, 1=observed mature)\n# $ section               : int: stream section number (usually 20-m lengths)  \n# $ enc                   : num: numeric indicator for capture (0=not captured, 1=captured)  \n# $ species               : chr: in pheno,  \"ATS\" \"BKT\" \"BNT\"\n# $ age                   : Factor: age in years at capture - be careful, this is a factor so use as.numeric(as.character(pheno$age)) to get meaningful #s\n# $ gtFirstOcc            : num: numeric indicator for an occasion greater than first capture (0 = first, 1 > first)\n# $ first                 : int: sample number of first capture\n# $ last                  : int:  sample number of last capture\n# $ cohort                : num: year that a fish is estimated to be age-0  \n# $ lagDate2              : POSIXct: date of next capture occasion\n# $ medianDate2           : POSIXct: median date of the sample occasion\n# $ everEmWest            : num: numeric indicator for permanent emigration from the West Brook system (includes Jimmy and Mitchell).\n#                                (1= yes, 0=no). Does not indcate occasion of last observation, just that a fish ever emigrated \n# $ fromTo                : int: not very useful here. indicator of movement from one stream segement in the previous occasion to the current occ \n# $ everMat01             : chr: indicator for whether a fish was ever observed as a mature male parr (1=yes, 0=no)\n# $ area                  : Factor: location indicator, \"ABOVE\"  \"BELOW\"  \"INSIDE\" \"TRIB\", inisde is sections 1-47 in the WB \n# $ riverM                : num: river meter from a fixed downstream location.  \n# $ tempDuringOccSampDays : num: average water temperature during the sampling occasion  \n# $ dischDuringOccSampDays: num: average water dishcarge during the sampling occasion\n# $ temperature           : num: average water temperature on the day of capture\n# $ discharge             : num: average water discharge on the day of capture\n# $ temperatureForP       : num: 'temperature' if captured, 'tempDuringOccSampDays' if not captured \n# $ dischargeForP         : num  'discharge' if captured, 'dischDuringOccSampDays' if not captured\n# $ medianDateSampleNum   : POSIXct: median date of the sampling occasion\n# $ propSampled           : num: proportion of the 47 sections that were sampled during occasions. Accounts for incomplete samples. Samples were all complete in the other rivers except for West Brook except for 2002 winter.  \n# $ propDaysOnAntEff      : num: proportion of days over the following interval we estimated (visually from a graph) that there were no reads on Duda's antennas - just for WEST now  \n# $ dateForEnv            : POSIXct: median sample date for non-capture occsasions, capture date (date2) for capture occasions. Used to fill in environmental data using addEnvironmentalData2\n# $ lagDateForEnv         : POSIXct: next occasion\n# $ matNA                 : num: numeric indicator for observed male parr maturity (1=yes, 0=no)  \n#                            1= matured in that maturity year (suummer-spring)\n#                            0 = observed immature in fall\n#                            NA = not observed mature and not captured in fall\n# $ intervalLength        :Class 'difftime': interval length in days\n# $ emPerm                : num: numeric indicator for occasion of permanent emigration (1=yes, 0=no)  \n# $ emPermNA              : num: numeric indicator for occasion of permanent emigration (1=yes, 0=no), with NAs after last occasion that a fish was observed\n# $ maxT                  : num: maximun temperature during the interval following the current occasion  \n# $ meanT                 : num:  mean temperature during the interval following the current occasion \n# $ medianT               : num:  median temperature during the interval following the current occasion \n# $ minT                  : num:  minimum temperature during the interval following the current occasion \n# $ sdT                   : num:  sd of temperature during the interval following the current occasion \n# $ skewT                 : num:  skew of temperature during the interval following the current occasion \n# $ maxD                  : num  maximun discharge during the interval following the current occasion \n# $ meanD                 : num  mean discharge during the interval following the current occasion\n# $ medianD               : num  median discharge during the interval following the current occasion\n# $ minD                  : num  minimum discharge during the interval following the current occasion\n# $ sdD                   : num  sd of discharge during the interval following the current occasion\n# $ skewD                 : num  skew of discharge during the interval following the current occasion\n#\n\n\n#############################################################################\n\n\n#library(ecoPiffle) #is this necessary?\nrequire(RPostgreSQL)\nrequire(lubridate)\nrequire(integrator)\nrequire(parallel)\nrequire(reshape2)\nrequire(lattice)\nrequire(latticeExtra)\nrequire(ggplot2)\nrequire(moments)\n#library(multicore) #linux only\nrequire(date) #to get month/day from julian date using date.mdy\nrequire(data.table)\n\nlink=db_connector(dbCredentials)\n\n#store the function's execution environment to \n#  enable calls to objects within a data.table\n#  when the name of the object is also a column \n#  name using get('objectName',env=execEnv)\nexecEnv<-environment()\n\npheno<-data.table(dbGetQuery(link$conn,\n                  \"SELECT * FROM data_corrected_tag_history;\"))\nsetnames(pheno,c(\"detection_date\",\"observed_length\"),\n               c(\"date\",          \"measured_length\"))\npheno[,cohort:=cohortEstimated]\npheno[,cohortEstimated:=NULL]\n#pheno[,sample_name:=as.numeric(sample_name)]\n\nsampleNames<-readRDS(file.path(processedDir,\"sampleNames.rds\"))\nsampleNames[,sample_name:=as.character(sample_name)]\nsampleNames<-sampleNames[drainage=='west',list(sample_name,season)]\nsampleNames[sample_name==\"89\",season:=\"PostSmolt\"]\n\nsetkey(pheno,sample_name)\nsetkey(sampleNames,sample_name)\n\npheno<-sampleNames[pheno]\n\n#############################################################################\n\n# subset variables for dMData\n# if include fish from cohorts < 1997, they will have ageInSamples that\n#don't go back to 1. for now we are leaving out cohort < 1997\n#when we want to include them, we'll need to augment back to ageInsamples 1\n#bay adding in negative smample numbers\nsubsetDMdataCohortMin <- cohorts[1] # >=\nsubsetDMdataCohortMax <- cohorts[2] # <=\n\nsubsetDMdataAgeInSamples <- 15 # <  \n\n# exclude fish that were captured for the first time after the\n# following ageInSamples\n# set equal to subsetDMdataAgeInSamples - 1 to have no effect \nmaxAgeInSamplesFirstCapt <- subsetDMdataAgeInSamples - 1 #4  0\n\n# this could be specified in the function call, but for now it's just \n#  set up for west brook\nif (species == 'ats'  ) {\n  riverSubset <- tolower(c('WEST BROOK'))#,'WB JIMMY') \n  #,'WB MITCHELL',\"WB OBEAR\") \n  #riverSubset <- c(\"SHOREY BROOK\") \n  # \"SAWMILL RIVER\",\"WB JIMMY\",\"WB OBEAR\", \"WB MITCHELL\", \"CATAMARAN BROOK\", \n  #riverSubset <- c(\"SAWMILL RIVER\")\n  areaSubset <- tolower(c('INSIDE', 'ABOVE', 'BELOW'))#, 'TRIB' ) \n\n}\n\nif (species %in% c('bkt','bnt')) {\n  riverSubset <- tolower(c('WEST BROOK','WB JIMMY','WB MITCHELL',\"WB OBEAR\")) \n  areaSubset <- tolower(c('INSIDE', 'ABOVE', 'BELOW', 'TRIB','ABOVE ABOVE',\n                          'aboveabove','BELOW BELOW' )) \n}\n\n# columns to include in  pheno2LongList\npheno2LongList <- c('tag','sample_name','sampleNumAdjConsec',\n                    'river','cohort','species',\n                    'season','age','measured_length',\n                    'section',\n                    #'sex','mature01','everMat01','measured_weight',\n                    'date','medianDate','area', 'riverN'\n)\n# columns to include in  pheno2LongList - need to update 'names' on next line\ndMDataList <-  c('tag','sample_name','sampleNumAdjConsec','measured_length',\n                 'section','enc', 'river', 'speciesConsec',\n                 'seasonConsec','ageConsec','ageInSamplesConsec',\n                 'yearConsec',\n                 'gtFirstOcc','firstConsec','lastConsec','cohortConsec',\n                 'date','medianDate',\n                 'area', 'riverN','emPerm'\n                 #,'mature01','everMat01Consec''measured_weight','sex'\n)\n\ndMDataNames <- c('tag','sampleName','sampleNum','length',\n                 'section','enc', 'river','species',\n                 'season','age','ageInSamples',\n                 'year',\n                 'gtFirstOcc','first','last','cohort',\n                 'date','medianDate',\n                 'area', 'riverN','emPerm'\n                 #,'everMat01','mature01','sex','weight'\n)                  \n\n#############################################################################\nemigration<-pheno[sample_name %in% c(\"antenna_detection\",\"trap\")]\n\n#get rid of the two summer obs and emigration detections\npheno <- pheno[season!=\"Summer\" & !is.na(season)]\npheno[,season:=as.numeric(factor(pheno$season,\n               levels=c(\"PreSmolt\",\"PostSmolt\",\"Fall\",\"PreWinter\"),\n               ordered=T))]\npheno[,sample_name:=as.numeric(sample_name)]\n\npheno[,medianDate:=median(date),by=sample_name]\n\npheno[,year:=year(date)]\npheno[,julian:=as.numeric(format(date,\"%j\"))]\npheno[,age:=year-cohort]\npheno[,daysOld:=julian + age * 365]\n\n# pheno[,mature01 := ifelse(maturity %in% c('p','m','f'),1,0)]\n# pheno[,everMat01:=max(mature01),by=tag]\n\npheno$riverN<-as.numeric(factor(pheno$river))\n\n#rename wB sample 41.8 to 42. 42 was a sampleComple==NO, \n# but there are equivalent samples in the other rivers\npheno[sample_name == 41.8,sample_name:=42 ]\n\n# get rid of duplicate tags on the same occasion\nsetkey(pheno,tag,sample_name)\npheno <- pheno[ !duplicated(pheno[,list(tag,sample_name)]), ]\n\n##########################\n# End of initial data prep \n##########################\n\n#############################################################################\n# subset species,river, and area                                                            \npheno2 <- pheno[species %in% get('species',env=execEnv) &\n                river   %in% riverSubset &\n                area    %in% areaSubset]\n\n#############################################################################\n# Generate data to set up long data format\n#############################################################################\nfirstYear   <- min(pheno2$year)\nfirstSample <- min(pheno2$sample_name)\n\nlastYear   <- max(pheno2$year)\nlastSample <- max(pheno2$sample_name)\n\n# set up template for all possible samples\nyearSeasonList <- as.data.frame(matrix(NA,(lastYear-firstYear+1)*4,2))\ni=0\nfor (y in 1:(lastYear-firstYear+1)){\n  for (s in 1:4){\n    i=i+1\n    yearSeasonList[i,1] <- y + firstYear -1\n    yearSeasonList[i,2] <- s\n  }  \n}    \nnames(yearSeasonList) <- c('year','season')\n\n# get list of actual samples from data\nsampleYearSeasonList <- unique(pheno2[,list(sample_name,season,year)])\nsetkey(sampleYearSeasonList,sample_name)\n#sampleYearSeasonList$season <- as.numeric(sampleYearSeasonList$season)\n# sample 47 has some fish in 2003 and 2004 (caught in Jan)\n#need to make sure sample 51 is year 2004\nsampleYearSeasonList[sample_name == 51,year:=2004]\nsampleYearSeasonList[sample_name == 47,year:=2003]\n\n#get rid of repeats for sample 47 and 51\nsampleYearSeasonList <- unique(sampleYearSeasonList)\n\n\n# add sampleNumAdj to yearSeasonList (template)\nyearSeasonList2 <- data.table(merge(\n  x = yearSeasonList, y = sampleYearSeasonList,\n  by = c('year','season'), all.x = TRUE\n))\n\n# fill in NAs for sampleNumAdj. Happens when species=ATS for winter samples\n#just hard-coding this for now. sample #s will always line up w year/season\nyearSeasonList2[year==2005 & season==4,sample_name:=55]\nyearSeasonList2[year==2002 & season==4,sample_name:=42]\nyearSeasonList2[year==2007 & season==4,sample_name:=63]\n\n\n\n#get rid of ANY unsampled samples - if left in, \n# trailing NA sampleNumAdj screw up evalRows [1/12/2012]\nyearSeasonList2 <- yearSeasonList2[ !is.na(sample_name), ] \n\nyearSeasonList2$sampleNumAdjConsec <- 1:nrow(yearSeasonList2)\n\n##################################################\n# add preceding sampleNums so old fish caught early can be augmented \n#  back before the study started\n##################################################\nfirstYear   <- (yearSeasonList2$year)[1]\nfirstSeason <- (yearSeasonList2$season)[1]\nnumOccAug   <- subsetDMdataAgeInSamples - 1 \n\naugBack <- as.data.frame(matrix(NA,numOccAug,ncol(yearSeasonList2)))\nnames(augBack) <- names(yearSeasonList2)\n\naugBack$sampleNumAdjConsec <- seq(-(numOccAug-1),0) \n# -1 to account for sampleNumConsec==0\n\naugBack$season[nrow(augBack)] <- firstSeason - 1\nif (augBack$season[nrow(augBack)] == 0) augBack$season[nrow(augBack)] <- 4 \n\naugBack$year[nrow(augBack)] <- firstYear - 0\nif (augBack$season[nrow(augBack)] == 4){\n  augBack$year[nrow(augBack)] <- firstYear - 1 \n}\n\nfor ( i in (numOccAug - 1) : 1 ){\n  augBack$season[i] <- augBack$season[i+1] - 1\n  if (augBack$season[i] == 0) augBack$season[i] <- 4\n  \n  augBack$year[i] <- augBack$year[i+1] - 0\n  if (augBack$season[i] == 4) augBack$year[i] <- augBack$year[i+1] - 1 \n  \n}     \n\nyearSeasonList3 <- rbind(augBack,yearSeasonList2)\n##################################################\n##################################################\n\n# add sampleNumAdjConsec to pheno2\npheno2 <- merge(\n  x = pheno2, y = yearSeasonList2[,list(sample_name,sampleNumAdjConsec)],\n  by = 'sample_name', all.x = TRUE\n)\n\nnOccTemplate <- nrow(yearSeasonList3)\nnInd <- length(unique(pheno2$tag))\n\n##############################################################################\n#make sampleNumConsec template for long format data\n##############################################################################\nsampNumTemplate <- rep(yearSeasonList3$sampleNumAdjConsec,nInd)\ntagNumTemplate <- sort(rep( unique(pheno2$tag), nOccTemplate ))\n\ntemplate <- data.table( tag=tagNumTemplate, sampleNumAdjConsec=sampNumTemplate) \n\n##############################################################################\n# merge pheno2 into template of tags and sampleNumAdjConsec\n##############################################################################\n#pheno2$sampleNumConsec) <- 'sampleNumAdjConsec'\n\npheno2<-pheno2[ , pheno2LongList,with=F ]\n\nsetkey(pheno2,   tag, sampleNumAdjConsec)\nsetkey(template, tag, sampleNumAdjConsec)\n\npheno2Long <- pheno2[template]\n\npheno2Long[,enc:=ifelse(is.na(sample_name),0,1)]\n\n\n##############################################################################\n# season index for each sample\n##############################################################################\nsampleToSeason <- unique(yearSeasonList3[,list(sampleNumAdjConsec,season)])\n#sort by sampleNumAdj - otherwise yearsMatrix is out of order\n\n##############################################################################\n# year index for each sample\n##############################################################################\nsampleToYear <- unique(yearSeasonList3[,list(sampleNumAdjConsec,year)])\n#sort by sampleNumAdj - otherwise yearsMatrix is out of order\n#sampleToYear <- sampleToYear[ order(sampleToYear$sampleNumAdjConsec), ]\n\nsampleTo <- data.table(sampleNumAdjConsec = sampleToSeason$sampleNumAdjConsec,\n                       seasonConsec       = sampleToSeason$season,\n                       yearConsec         = sampleToYear$year)\n\npheno2Long <- merge(\n  x = pheno2Long, y = sampleTo,\n  by = c('sampleNumAdjConsec'), all.x = TRUE, sort=FALSE\n)\n\n##############################################################################\n#get individual-specifc lists and prepare to merge into pheno2Long\n##############################################################################\n##############################################################################\n# variables that don't change within fish\n##############################################################################\nboundaryDetections<-data.table(dbGetQuery(link$conn,\n                    \"SELECT * FROM data_boundary_detections;\"))\nboundaryDetections<-boundaryDetections[,list(\n                    lastBoundaryDetection=max(detection_date)),\n                    by=tag]\n\nsetkey(boundaryDetections,tag)\n\nbyTag<- unique(pheno2[,list(cohortConsec     = cohort,\n                            #everMat01Consec = everMat01,\n                            speciesConsec    = species,\n                            firstConsec      = min(sampleNumAdjConsec,na.rm=T),\n                            lastConsec       = max(sampleNumAdjConsec,na.rm=T),\n                            firstDate        = min(date,na.rm=T),\n                            lastDate         = max(date,na.rm=T)),\n                      by=tag])\n\nif(sum(duplicated(byTag$tag))){\n  stop('duplicate tag numbers created when making byTag, \n       which includes variables that do not vary by tag')\n}\n\nsetkey(byTag,tag)\nbyTag<-boundaryDetections[byTag]\n\n\npheno2Long <- merge(\n  x = pheno2Long, y = byTag,\n  by = 'tag', all.x = TRUE\n)\n\n#create ageConsec column for each fish\npheno2Long[,ageConsec:=yearConsec -cohortConsec] \n# + 2 so season 2 is ageInSamples\npheno2Long[,ageInSamplesConsec:=4*(ageConsec-1) + 2 + seasonConsec]\n\n# delete fish that were caught for the first time too old\nbyTag[,notTooOld:=\n        pheno2Long[sampleNumAdjConsec == firstConsec ,\n                   ageInSamplesConsec <= maxAgeInSamplesFirstCapt,\n                   by=tag]$V1]\npheno2Long <- pheno2Long[tag %in% byTag[notTooOld==TRUE,tag]]\n\n\nsetkey(pheno2Long,tag,sampleNumAdjConsec)\n\n#pheno2Long[pheno2Long$tag=='1BF20EA597',]\n\n# #########################################################################\n# ### Create indicator of permanent emigration \n# ### (defined as last observation at boundary antenna #\n# {should this include outside?})\n# ### using the antenna data\npheno2Long[,medianDateSampleNum := median(date,na.rm=T),\n            by=sampleNumAdjConsec]\n\npheno2Long[is.na(lastBoundaryDetection) | \n             lastDate            > lastBoundaryDetection |\n             medianDateSampleNum > lastBoundaryDetection,\n           emPerm:=0]\npheno2Long[is.na(emPerm),\n           emPerm:=ifelse(sampleNumAdjConsec == max(sampleNumAdjConsec),1,0),\n           by=tag]\npheno2Long[,emigrated:=ifelse(any(emPerm==1),\n                              as.numeric(date>date[which(emPerm==1)]),\n                              0),\n           by=tag]\n\n##############################################################################\n# prepare to create availability column\n##############################################################################\nnOcc <- max(yearSeasonList3$sampleNumAdjConsec)\n\n# fish are not available when they are too old                        \n##or if they have emigrated\n# fish are not available before first capture\nif(modelType=='cjs'){\npheno2Long[,available:=(ageInSamplesConsec <  subsetDMdataAgeInSamples &\n                        sampleNumAdjConsec >= firstConsec)-0]\n}\n\nif(modelType=='js'){\n  pheno2Long[,available:=(ageInSamplesConsec < subsetDMdataAgeInSamples &\n                          yearConsec > studyYears[1]) -0]\n  \n}\n\n# delete fish that were seen for the first time after subsetDMdataAgeInSamples\ntooOld <- unique(pheno2Long[ seasonConsec       == firstConsec &\n                             ageInSamplesConsec >  subsetDMdataAgeInSamples,\n                            tag ])\n\npheno2Long <- pheno2Long[ !(tag %in% tooOld) ]\n\npheno2Long[sampleNumAdjConsec<1,available:=0]\n\npheno2Long[,gtFirstOcc:=ifelse(sampleNumAdjConsec>firstConsec,1,0)]\n\npheno2Long[emigrated==1,available:=0]\n\n##############################################################################\n# subset for availability ==1. Final input dataset for analysis\n##############################################################################\n\ndMData <- pheno2Long[available==1,dMDataList,with=F]\n\n# dMDataList names defined up top\nsetnames(dMData, dMDataNames)\ndMData<-dMData[cohort       >= subsetDMdataCohortMin &\n               cohort       <= subsetDMdataCohortMax &\n               ageInSamples <  subsetDMdataAgeInSamples]\n\n##############################################################################\n#add in proportion of sections sampled \n\ndMData$propSampled<-1\n# fix incomplete samples to the proportion of sections sampled\n\n# WEST - 2002, no river was sampled in winter 2002\ndMData[year == 2002 & season == 4, propSampled:=0 ]\n\n# West Brook samples were not complete in the following years in winter\ndMData[river == 'west brook' & year == 2003 & season == 4, propSampled:=30/47 ] \n\ndMData[ river == 'west brook' & year == 2004 & season == 4, propSampled:=3/47 ]\n\ndMData[ river == 'west brook' & year == 2005 & season == 4, propSampled:=0]\n\ndMData[ river == 'west brook' & year == 2007 & season == 4, propSampled:=0 ]                                 \n\n##############################################################################\n\n##############################################################################\n# add environmental data to each row of dMData\n##############################################################################\n#envData <- as.data.frame(read.csv(file=\"./envData.txt\", header=TRUE))                                         \n# file created using access file query  fourRiversAllSpp:envData query\n# in C:\\PITTAGMAIN\\CMR Analyses\\Hierach_Bugs\\allSpp\n#export query as text file without formatting\n# then copy to felek\nenvData<-data.table(dbGetQuery(link$conn,\"SELECT * FROM data_environmental;\"))\nsetnames(envData,\"day_of_year\",\"julian\")\nenvData[,date:=as.Date(date_ct)]\n\n#need to add medianDate and lagMedianDate to row for which fish were not caught\n# fill in median dates for samples with no data (e.g winters)\nmedianDateListForMissing<-dMData[enc==1,\n                                 list(min(    date , na.rm=T),\n                                      max(    date , na.rm=T),\n                                      median( date , na.rm=T)),\n                                 by=sampleNum]\nsetnames(medianDateListForMissing,\n         c(\"sampleNum\",\"minDate\",\"maxDate\",\"medianDateSampleNum\"))\nmedianDateListForMissing[,c(\"minJulian\",\"maxJulian\",\"medianJulian\",\"year\"):=\n                           list(as.numeric(format(minDate,\"%j\")),\n                                as.numeric(format(maxDate,\"%j\")),\n                                as.numeric(format(medianDateSampleNum,\"%j\")),\n                                as.numeric(format(medianDateSampleNum,\"%Y\")))]\n\n\n# saving for antennaDuda.r, so we can make graphs of antenna data\n#save(medianDateListForMissing, file= './medianDateListForMissing.RData')\n\n\n\n#calulate T and discharge means between dateMin and dataMax for each sample\n# I'm sure these's a better way to do this, but this works...\nmeansDuringSample <- as.data.frame(matrix(NA,nrow(medianDateListForMissing),6))\nnames(meansDuringSample) <- c('drainage','sampleNum',\n                              'tempDuringOcc','dischDuringOcc',\n                              'tempDuringOccSampDays','dischDuringOccSampDays')                                 \n\nsampleDateList <- unique(dMData[!is.na(date),list(sampleNum,date)])\n\ngetMeanDuringSample<-function(sample,type,river){\n  envData[date %in% sampleDateList[sampleNum==sample,date] & \n            river == river,\n          mean(get(type),na.rm=T)]\n}\n\nmedianDateListForMissing[,c(\"tempDuringOccSampDays\",\"dischDuringOccSampDays\"):=\n                           list(mapply(getMeanDuringSample,\n                                       sample   = sampleNum,\n                                       type     = \"temperature\",\n                                       MoreArgs = list(river='west brook')),\n                                mapply(getMeanDuringSample,\n                                       sample   = sampleNum,\n                                       type     = \"discharge\",\n                                       MoreArgs = list(river='west brook')))]\n\nmeansDuringSample<-medianDateListForMissing[,list(sampleNum,\n                                                  tempDuringOccSampDays,\n                                                  dischDuringOccSampDays)]\n\nsetkey(sampleToSeason,sampleNumAdjConsec)\nsetkey(meansDuringSample,sampleNum)\nmeansDuringSample<-meansDuringSample[sampleToSeason]\n\n# use tempDuringOccSampDays for analyses - is the mean of actual days samples, \n# not over range like tempDuringOcc                            \n\n#need to fill in NaN entires in meansDuringSample. 1st get means, \n#then merge in when entry is NaN\n\n# add rows for samples not Attempted\n\nmeansBySeason<-meansDuringSample[,list(mean(tempDuringOccSampDays,na.rm=T),\n                                       mean(dischDuringOccSampDays,na.rm=T)),\n                                 by=season]\nsetnames(meansBySeason,\n         c(\"season\",'tempDuringOccSampDays','dischDuringOccSampDays'))\n# replace NaNs in meansDuringSample. these come from incomplete data in envData\n#should thoroughly check indexing and column names here\nfillWithMeans<-function(x,type){value<-\n                                 meansBySeason[season==x,\n                                               ifelse(type=='temperature',\n                                                      tempDuringOccSampDays,\n                                                      dischDuringOccSampDays)]\n                                return(value)\n}\n\nmeansDuringSample[is.na(tempDuringOccSampDays),\n                  c(\"tempDuringOccSampDays\",\"dischDuringOccSampDays\"):=\n                    list(mapply(fillWithMeans,\n                                x = season,\n                                MoreArgs = list(type='temperature')),\n                         mapply(fillWithMeans,\n                                x = season,\n                                MoreArgs = list(type='discharge')))]\nmeansDuringSample[,season:=NULL]\n# for ATS, 33 is NaN becasue minDate=maxDate\n#add T and flow to each row of data as covariates for p(capt)\n# merging on drainage for now because data are incomplete for river\nsetkey(dMData,sampleNum)\ndMData <-meansDuringSample[dMData]\n\n#merge in actual temp and disch for each fish\ndMData <- merge(\n  x = dMData, y = envData[,list(river,date,\n                                temperature, discharge)],\n  by = c('river','date'), all.x = TRUE\n)\n\n\n\n#keep actual env data if capture, otherwise keep mean during sample.\n# with movement model, could estimate location and then estimate day of\n# capture to get est env data\n\n# this adds in data when it's missing for the date of capture (SHOREY)\ndMData[,temperatureForP:=ifelse(is.na(date) | is.na(temperature),  \n                                tempDuringOccSampDays,\n                                temperature )]\n# this adds in data when it's missing for the date of capture (SHOREY)\ndMData[,dischargeForP:=ifelse(is.na(date) | is.na(discharge),  \n                              dischDuringOccSampDays,\n                              discharge )]\n\n\n\n\n#ggplot(envData,aes(date,temperature)) + geom_point() + \n#  facet_wrap(~drainage)\n#ggplot(subset(envData,drainage=='WEST'),aes(date2,temperature)) + geom_point() + \n#  facet_wrap(~river)\n#ggplot(subset(envData,river=='WEST BROOK'),aes(julian,(discharge+0.0)))  + \n#  geom_line() + ylim(c(0,15)) + theme_bw() +\n#  facet_wrap(~year) + \n#  geom_vline(aes(xintercept=julianMin),medianDateListForMissing, colour='blue') +\n#  geom_vline(aes(xintercept=julianMedian),medianDateListForMissing, linetype=2) +\n#  geom_vline(aes(xintercept=julianMax),medianDateListForMissing,colour='red')\n#\ndMData <- merge(\n  x = dMData, y = medianDateListForMissing[,list(sampleNum,medianDateSampleNum)],\n  by = c('sampleNum'), all.x = TRUE\n)\n\n\n# set up template for all possible samples for antenna efficiency\nfirstYearAnt <- 1997; lastYearAnt <- 2015\nyearSeasonListAnt <- as.data.frame(matrix(NA,(lastYearAnt-firstYearAnt+1)*4,2))\ni=0\nfor (y in 1:(lastYearAnt-firstYearAnt+1)){\n  for (s in 1:4){\n    i=i+1\n    yearSeasonListAnt[i,1] <- y + firstYearAnt -1\n    yearSeasonListAnt[i,2] <- s\n  }  \n}    \nnames(yearSeasonListAnt) <- c('year','season')\n\n# set default to 0.1 so fish below \n# have a chance of detection when antennas were not working\nyearSeasonListAnt$propDaysOn <- 0.1\n\n#numbers based on graph in antennaDuda.r. \n# Fill in rest for other year/season combos (e.g. when run trout)\nyearSeasonListAnt$propDaysOn[19:43] <- (c(10,80,100,95,100,65,100,80,90,100,100,\n                                          80,100,100,100,90,100,50,100,100,100,\n                                          100,95,85,90) ) / 100\nyearSeasonListAnt$drainage <- 'WEST'\n#yearSeasonListAnt$antEfficiency <- 1 #0.9 #make interval-specific\n#yearSeasonListAnt$propDaysOnAntEff <- yearSeasonListAnt$propDaysOn * \n#                                  yearSeasonListAnt$antEfficiency\n\ndMData <- merge(\n  x = dMData, y = yearSeasonListAnt[,c('year','season','drainage','propDaysOn')],\n  by = c('year','season'), all.x = TRUE\n)\n\n\n#hard code missing winter samples if they are missing\n# dMData[ is.na( medianDate ) &  \n#         year == 2002 & \n#         season == 4 ] <- '2002-12-04' \n# dMData$medianDateSampleNum[ is.na( dMData$medianDateSampleNum ) & \n#                               dMData$drainage == 'WEST' & \n#                               dMData$year == 2005 & \n#                               dMData$season == 4 ] <- '2005-12-04' \n# dMData$medianDateSampleNum[ is.na( dMData$medianDateSampleNum ) & \n#                               dMData$drainage == 'WEST' & \n#                               dMData$year == 2007 & \n#                               dMData$season == 4 ] <- '2007-12-04' \n\ndMData[,dateForEnv:=date]\ndMData[is.na(date),dateForEnv:=medianDateSampleNum,]\n\naddLagged<-function(data,individual,time,lag,k=1){\n  #data is the data as a data.table\n  #individual is the name of the column containing the \n   #identifier for individuals in quotes\n  #time is the column that determines the order of observations\n  #lag is the column that will be lagged\n  #k is the number of lags, positive values lag forward and \n   #negative values lag backwards\n  \n  if(!is.data.table(data)){stop('data must be a data.table')}\n  keycols<-c(individual,time)\n  setkeyv(data,keycols)\n  \n  for(i in lag){\n    data[,\n         #make the name for the new column in camelCase\n         c(paste0(\"lag\",toupper(substr(i,1,1)),substr(i,2,100))):=list( \n           #second part of the following is just to make the output of \n           #ifelse the same shape as the hole it fills\n      ifelse(k>=0 & 1:length(get(i)) > 0, \n             #if k>=0, pad with NAs at the end\n             c(get(i)[(k+1):length(get(i))],rep(as.numeric(NA),k)),\n             #pad with NAs at the beginning if k<0\n             c(rep(as.numeric(NA),abs(k)),get(i)[1:(length(get(i))-k)]))),\n      by=get(individual)]\n  }\n  return(data)  \n}\n\ndMData <- addLagged(data = dMData, individual = \"tag\", time = \"dateForEnv\", \n                    lag =\"dateForEnv\")\ndMData[,lagDateForEnv:=as.Date(lagDateForEnv,origin=\"1970-01-01\")]\n\n\n############################################################\n# separates first occ from others for likelihood\n############################################################\n\n# use below if there is only one row of gtFirstOcc per fish\n# not true when augmenting back to ageInSamples==1\n#firstObsRows <- subset(1:nrow(dMData),dMData$gtFirstOcc==0) \n\ndMData[,lastAIS:=max(ageInSamples,na.rm=T),by=tag]\n\n#if limit years so that early samples for an older cohort are cut off, \n# can get fish with 0\n#observations. This messes up the evalRows etc\n#minSAmpleNum <- min(dMData$sampleNum)\n#dMData2  <- dMData[ dMData$last > minSAmpleNum, ]\n\n\nsetkey(dMData,tag,sampleNum)  # MUST order before doing eval rows.\n\n#########################################################\n# 1= matured in that maturity year (suummer to next spring)\n# 0 = observed immature in fall\n# NA = not observed mature and not captured in fall\n\n#create an age in maturity years to group by\ndMData[,ageGroup:=floor(ageInSamples/4)]\n\n# #assign matNA based on above criteria\n# dMData[ageGroup>0,bla:=ifelse(any(mature01==1,na.rm=T),\n#                               1,\n#                               ifelse(length(which(season==3))==0,\n#                                      as.numeric(NA),\n#                                      mature01[which(season==3)])),\n#        by=list(tag,ageGroup)]\n# dMData[,ageGroup:=NULL]\n\n#Remove any maturity indicators that are not summer\n# dMData[season!=2,bla:=NA]\n##############################################################\n\ndMData[,intervalLength:=difftime(lagDateForEnv,dateForEnv, unit=\"days\")]\n\n\n\n\n\n# #########################################################################\n# #########################################################################\n# \n# #########################################################################\n# ### AntennaTrib\n# #########################################################################\n# # \n# # \n# \n# antennaTribs <- as.data.frame(read.csv(file=\"./antennaTribs.txt\", header=TRUE))                                         \n# # file created using access file query  fourRiversAts:antennaDuda query\n# # in C:\\PITTAGMAIN\\CMR Analyses\\Hierach_Bugs\\allSpp\n# #export query as text file without formatting\n# # then copy to felek\n# \n# antennaTribs$date2 <- as.POSIXct(strptime(antennaTribs$date, \n#                                  format = \"%m/%d/%Y\"))\n# antennaTribs$tagNumberCH <- as.character(antennaTribs$tagNumber)\n# \n# #countAntennaTribs <- ddply( antennaTribs[,c('tagNumber','river','date2')], \n                               #.(tagNumber, river),  \n# #  \t\t\t\t\t\tsummarise,  ct=length(date2)\n# #\t\t   \t\t\t\t  ) \n# #countAntennaTribs <- countAntennaTribs[ order(countAntennaTribs$tagNumber,\n#                                          countAntennaTribs$river),]\n# \n# \n# # count the number of time a fiSh waS oberved on trib antenna\n# # for each interval between dateForEnv and lagDataForEnv\n# # takeS a LONG time to run - need to improve on loopS\n# # AlSo need to makeSure dateForEnv iS acting ok.\n# #if (runAntennaCount) {\n# \n# #dMData$antennaCountJimmy <- 0\n# #dMData$antennaCountMitchell <- 0\n# \n# #for ( i in 1 : nrow( dMData ) ) {\n# #\thold <- antennaTribs[ antennaTribs$tagNumberCH == dMData$tagNumberCH[i], ]\n# \n# #\tcJimmy <- 0\n# #\tcMitchell <- 0\n# \n# #\tif ( nrow(hold) > 0 & \n# #\t     !is.na(dMData$river[i]) &\n# #\t     !is.na(dMData$dateForEnv[ i ]) &\n# #\t     !is.na(dMData$lagDateForEnv[ i ] ) ) {\n# \n# #\t\tfor ( j in 1 : nrow(hold) ) {\n# #\t\t\tif( hold$river[j] == 'WB JIMMY' &\n# #\t\t\t\thold$date2[j] > dMData$dateForEnv[ i ]  &\n# #\t\t\t\thold$date2[j] <= dMData$lagDateForEnv[ i ] ) cJimmy <- cJimmy + 1\n# #\t\t\n# #\t\t\tif( hold$river[j] == 'WB MITCHELL' &\n# #\t\t\t\thold$date2[j] > dMData$dateForEnv[ i ]  &\n# #\t\t\t\thold$date2[j] <= dMData$lagDateForEnv[ i ] ) cMitchell <- \n#                                                      cMitchell + 1\t\n# #     }\n# \n# #\t}\n# \n# #\tdMData$antennaCountJimmy[ i ] <- cJimmy\n# #\tdMData$antennaCountMitchell[ i ] <- cMitchell\n# #\tif ( i %% 50 == 0 ) print( c( i,nrow(dMData),Sys.time() ) )\n# #}\t\n# \n# #}    \n# \n# #thiS work faster\n# m <- merge ( x = dMData, y=antennaTribs[,c('river','tagNumberCH','date2')],\n#                                          by = c('tagNumberCH'), all.x=TRUE)\n# #m <- m[order(m$tagNumberCH,m$sampleNum),]\n# m$antennaHit <- ifelse( m$date2.y > m$dateForEnv & \n#                           m$date2.y <= m$lagDateForEnv,\n#                         1, 0 )\n# \n# m$antennaHit[ is.na( m$antennaHit) ] <- 0\t\t                \n# \n# # too Slow\n# #mHit <- ddply( m, .(river.y, tagNumberCH, sampleNum), summarise, \n#                   sum( antennaHit ), .progress = \"text\" )\t\t                \n# \n# #mHit <- tapply(m$antennaHit,\n#                 list(m$river.y, m$tagNumberCH, m$sampleNum), sum)\n# mHit <- aggregate( m$antennaHit , \n#                    by=list( m$river.y, m$tagNumberCH, m$sampleNum ),\n#                    FUN=sum, na.rm =TRUE )\n# \n# names(mHit) <- c('river','tagNumberCH','sampleNum','antennaCount')\n# \n# rm(m)\n# \n# mHitJimmy <- subset(mHit, river == 'WB JIMMY')\n# mHitMitchell <- subset(mHit, river == 'WB MITCHELL')\n# mHitOBear <- subset(mHit, river == 'WB OBEAR')\n# \n# names(mHitJimmy) <- c('antennaTrib','tagNumberCH', \n#                       'sampleNum', 'antennaCountJimmy')\n# names(mHitMitchell) <- c('antennaTrib','tagNumberCH', \n#                          'sampleNum', 'antennaCountMitchell')\n# names(mHitOBear) <- c('antennaTrib','tagNumberCH', \n#                       'sampleNum', 'antennaCountOBear')\n# \n# \n# dMData <- merge ( x = dMData, y=mHitJimmy[,2:4], \n#                   by = c('tagNumberCH', 'sampleNum'), all.x=TRUE)\n# dMData <- merge ( x = dMData, y=mHitMitchell[,2:4], \n#                   by = c('tagNumberCH', 'sampleNum'), all.x=TRUE)\n# dMData <- merge ( x = dMData, y=mHitOBear[,2:4], \n#                   by = c('tagNumberCH', 'sampleNum'), all.x=TRUE)\n# \n# \n# dMData$antennaCountJimmy[ is.na( dMData$antennaCountJimmy ) ] <- 0\t\t                \n# dMData$antennaCountMitchell[ is.na( dMData$antennaCountMitchell ) ] <- 0\n# dMData$antennaCountOBear[ is.na( dMData$antennaCountOBear ) ] <- 0\n# \n# dMData$antennaCountJimmyGT1 <- ifelse(dMData$antennaCountJimmy >0, 1, 0)\n# dMData$antennaCountMitchellGT1 <- ifelse(dMData$antennaCountMitchell >0, 1, 0)\n# dMData$antennaCountOBearGT1 <- ifelse(dMData$antennaCountOBear >0, 1, 0)\n# \n# # get list of fish that moved from OBear to WB - \n# #  this is better than fromTo becasue is doesn't rely on consec samples\n# #could do the same thing for other movements...\n# wBAndOB <- ddply(dMData[!is.na(dMData$river),], .(tagNumberCH), function(x) {\n#              any(x$river == c('WEST BROOK')) * any(x$river == c('WB OBEAR'))})\n# wBAndOBTN <- wBAndOB[wBAndOB$V1 == T,1]\n# \n# dMData$wBAndOB <- ifelse( dMData$tagNumberCH %in% wBAndOBTN, 1,0 )\n# \n\n##################################\n\n#######################################################\n# Fill in river observations for missing occasions\n# observations per individual in each river\n\n\nmaxRiver<-dMData[!is.na(riverN),\n                 length(year),\n                 by=list(tag,riverN)][,riverN[which.max(V1)],\n                                      by=tag]\nsetnames(maxRiver,\"V1\",\"maxRiver\")\nsetkey(maxRiver,tag)\n\n# NOTE - this lags backwards\ndMData <- addLagged(data = dMData, individual = \"tag\", time = \"sampleNum\", \n                    lag = c(\"riverN\"), k=-1)\n# Fills in most common river per tagNumber (r$maxRiver[ dMData$tagNumber ]) \n#  before first sample\n# Keeps river for observed occasions and grabs lagged (backwards)\n#  river for first uncaptured occasion\ndMData[,riverN:=ifelse(sampleNum<first,riverN[which(!is.na(riverN))[1]],riverN),by=tag]\n\ndMData[,riverN:=\n         ifelse(length(unique(na.omit(riverN)))==1,\n                unique(na.omit(riverN)),\n                riverN),\n       by=tag]\n\n\n\n\ndMData[,riverConsec:=ifelse(sampleNum < first,\n                            maxRiver[tag,\n                                     maxRiver],\n                            ifelse(!is.na(riverN),\n                                   riverN,\n                                   lagRiverN\n                            )\n)\n]\n\n#######Add lagged versions of key variables##############################\ndMData <- addLagged(data = dMData, individual = \"tag\", time = \"sampleNum\", \n                    lag = c(\"sampleNum\",\"riverN\",\"length\",\"date\"))   \n#########################################################################\n\n###################I'm not sure what addEnvironmentalData2 does..\n###################so I'll need to rewrite this after figuring that out, \n #commenting out for now\n#dateTime...' are the date cols in the pheno data\n# (before <- Sys.time())\n# dMData <- addEnvironmentalData2(\n#   dMData, envData, lagDateTimeCol = \"dateForEnv\", \n#   dateTimeCol = \"lagDateForEnv\", \n#   dateCol = \"date2\", temperatureColumn = \"temperature\", \n#   dischargeColumn = \"discharge\" )\n# (after <-Sys.time())     \n# difftime(after,before)  \n# \n# # fill in 'samples' before the study starts with means\n# \n# envMeans <- aggregate((dMData[,c('intervalLength','maxT','meanT',\n#                                  'medianT','minT','sdT','skewT',\n#                                  'maxD','meanD','medianD','minD',\n#                                  'sdD','skewD') ] ),\n#              by=list( dMData$drainage,dMData$season ),FUN=mean, na.rm =TRUE )\n# names(envMeans)[1:2] <- c('drainage','season')\n# \n# ##############################################################################\n# ##############################################################################\n# #### Temporary fix to fill in mean data for augmented back rows ##############\n# ##############################################################################\n# dMData$seasonMeanIntLen<-envMeans$intervalLength[match(dMData$season,\n#                                                        envMeans$season)]\n# dMData$seasonMeanT <- envMeans$meanT[ match(dMData$season,envMeans$season) ]\n# dMData$seasonMeanD<-envMeans$meanD[match(dMData$season,envMeans$season)]\n# dMData$fullMeanIntLen<-dMData$intervalLength\n# dMData$fullMeanT<-dMData$meanT\n# dMData$fullMeanD<-dMData$meanD\n# dMData$fullMeanIntLen[which(is.na(dMData$intervalLength))]<-\n#     dMData$seasonMeanIntLen[which(is.na(dMData$intervalLength))]\n# dMData$fullMeanT[which(is.na(dMData$meanT))]<-\n#     dMData$seasonMeanT[which(is.na(dMData$meanT))]\n# dMData$fullMeanD[which(is.na(dMData$meanD))]<-\n#     dMData$seasonMeanD[which(is.na(dMData$meanT))]\n# ##############################################################################\n# ##############################################################################\n# ##############################################################################\n# ##############################################################################\n# \n# dMData <- dMData[ order(dMData$tagNumber,dMData$sampleNum),]   \n# \n# ##############################################################################\nif(modelType=='js'){\n  dMData[,sampleNumAdj:=sampleNum-min(sampleNum)+1]\n}\n\nnSamples <- dMData[,max(sampleNumAdj)]\nsamples <- dMData[,list(sampleNumAdj,sampleNum,season,year)]\nsetkey(samples,sampleNumAdj,sampleNum,season,year)\nsamples<-unique(samples)\nsummerSamples<-samples[,which(season==2)]\nnSummerSamples<-length(summerSamples)\nnonSummerSamples<-samples[,which(season!=2)]\nnNonSummerSamples<-length(nonSummerSamples)\n\nnRivers<-dMData[!is.na(riverN),\n                length(unique(riverN))]\n\n########################################################################\nif(modelType=='js'){\n  \n  knowns <- function(samplesInData,cohort,last){\n    if(cohort<min(samples$year)){born<-1+(cohort-min(samples$year))*4\n    } else {\n    born <- samples[year==cohort & season == 2, sampleNumAdj]\n    }\n    unknownAfter <- samples[sampleNum==last,sampleNumAdj]\n    \n    z<-rep(NA,max(samplesInData))\n    z[samplesInData < born] <- 1 #sets state to not entered before birth\n    z[samplesInData >= born & samplesInData <= unknownAfter] <- 2 #alive when known\n    z[(samplesInData-born) >=4 & z==2]<-3 #adult after age in samples 4\n    return(z)\n  }\n  \n  dMData[,zKnown:=knowns(sampleNumAdj,unique(cohort),unique(last)),by=tag]\n  dMData[sampleNumAdj==1,zKnown:=1] #everyone starts the study not entered\n  \n  d<-dMData[,list(sampleNumAdj,\n                  riverN,\n                  enc,\n                  zKnown)]\n  \n  for(r in 1:nRivers){\n    nExtras<-round(dMData[riverN==r,length(unique(tag))]*0.3)\n    assign(paste0('aug',r),\n           data.table(sampleNumAdj=rep(1:nSamples,nExtras)))\n    get(paste0('aug',r))[,c(\"riverN\",\"enc\",\"zKnown\"):=\n                           list(r,    0,   as.numeric(NA))]\n  }\n  aug<-rbind(aug1,aug2,aug3,aug4)\n  aug[sampleNumAdj==1,zKnown:=1]\n  d<-rbind(d,aug)\n  d[,enc:=abs(enc-2)]\n  \n}\n\n\nif(modelType=='js'){\n  firstObsRows<- d[,which(sampleNumAdj==1)]\n  nFirstObsRows <- length( firstObsRows )\n  lastObsRows <- c(firstObsRows[2:nFirstObsRows]-1,nrow(d))\n  nLastObsRows <- length(lastObsRows)\n  \n  evalRows <- d[,which(sampleNumAdj!=1)]\n  nEvalRows <- length(evalRows)\n  \n  evalJSRows <- dMData[,which(ageInSamples != lastAIS)]\n  nEvalJSRows <- length(evalJSRows) \n}\n\nif(modelType!='js'){\nfirstObsRows= dMData[,which(first==sampleNum)]\nnFirstObsRows <- length( firstObsRows )\nlastObsRows <- dMData[,which(is.na(lagDateForEnv))]\nnLastObsRows <- length(lastObsRows)\n\nevalRows <- dMData[,which(!is.na(lagDateForEnv) & sampleNum >= first)]\nnEvalRows <- length(evalRows)\n\nevalJSRows <- dMData[,which(ageInSamples != lastAIS)]\nnEvalJSRows <- length(evalJSRows)   \n\n}\n\n\n############################################################\n# variables for estimating pMat\nsummerObsRows <- dMData[,which(season == 2)]\nnSummerObsRows <- length(summerObsRows)\n\nnonSummerObsRows <- dMData[,which(season!=2)]\nnNonSummerObsRows <- length(nonSummerObsRows)\n\noccasions <-unique(dMData[,list(ageInSamples,season)])\nsummerAIS <- occasions$ageInSamples[occasions$season == 2]\nnonSummerAIS <- occasions$ageInSamples[occasions$season != 2]\n\n###################################################################\nif(modelType=='js'){\nevalList <- list(evalRows          = evalRows,\n                 nEvalRows         = nEvalRows,\n                 nSamples          = nSamples,\n                 samples           = samples,\n                 nRivers           = nRivers,\n                 summerSamples     = summerSamples,\n                 nSummerSamples    = nSummerSamples,\n                 nonSummerSamples  = nonSummerSamples,\n                 nNonSummerSamples = nNonSummerSamples)\n}\n\nif(modelType=='cjs'){\nevalList <- list(firstObsRows      = firstObsRows,\n                 nFirstObsRows     = nFirstObsRows,\n                 lastObsRows       = lastObsRows,\n                 nLastObsRows      = nLastObsRows,\n                 evalRows          = evalRows,\n                 nEvalRows         = nEvalRows,\n                 evalJSRows        = evalJSRows,\n                 nEvalJSRows       = nEvalJSRows,\n                 summerObsRows     = summerObsRows,\n                 nSummerObsRows    = nSummerObsRows,\n                 nonSummerObsRows  = nonSummerObsRows, \n                 nNonSummerObsRows = nNonSummerObsRows,\n                 summerAIS         = summerAIS,\n                 nonSummerAIS      = nonSummerAIS,\n                 nSamples          = nSamples,\n                 samples           = samples,\n                 nRivers           = nRivers,\n                 summerSamples     = summerSamples,\n                 nonSummerSamples  = nonSummerSamples)\n}\n######################################################################\n# # means for standardizing\n# lengthStd <- tapply(dMData$length,dMData$ageInSamples,mean, na.rm=TRUE)     \n# # need to do this for the SR, so fish in AIS 10,13,14\n# \n# stdList <-\n#   list(\n#     lengthStd = lengthStd\n#     #tempStd = tapply(dMData$fullMeanT,dMData$season,mean),\n#     #flowStd = tapply(dMData$fullMeanD,dMData$season,mean) \n#   )\n# \n# # for cohort by ais means\n# nAgeInSamples = length(unique(dMData$ageInSamples))\n# nCohorts = length(unique(dMData$cohort))\n# cohortIndex<-dMData$cohort\n# \n# aisMeans <- dMData[,mean(length,na.rm=T),by=ageInSamples]\n# setnames(aisMeans,\"V1\",\"aisMeanLength\")\n# aisCohortMeans <- dMData[,mean(length,na.rm=T),by=list(cohort,ageInSamples)]\n# setnames(aisCohortMeans,\"V1\",\"aisCohortMeanLength\")\n# \n# \n# setkey(aisMeans,ageInSamples)\n# setkey(aisCohortMeans,ageInSamples)\n# aisCohortMeans<-aisMeans[aisCohortMeans]\n# aisCohortMeans[is.na(aisCohortMeanLength),aisCohortMeanLength:=aisMeanLength]\n# \n# \n# stdList_cohort <-\n#   list(\n#     lengthStd = aisCohortMeans\n#     #tempStd = tapply(dMData$fullMeanT,dMData$season,mean),\n#     #flowStd = tapply(dMData$fullMeanD,dMData$season,mean) \n#   )\n\n##########################################################\n# do counts for stdN in the growthSurvivalMove model. \n#need counts of fish from all cohorts for estimate of N\nif(modelType=='someFutureType'){\nscaleVec<-function(x,na.rm=F){(x-mean(x,na.rm=na.rm))/sd(x,na.rm=na.rm)}\nnRivers <- length(unique(dMData[!is.na(river),river]))\nnYears = max(dMData$year)-min(dMData$year)+1\n\n\ncount2 <-pheno2Long[enc == 1,\n                    length(c(tag)),\n                    by=list(seasonConsec,yearConsec,riverN)]\nsetnames(count2,\"V1\",'count')\ncount2[,riverN:=riverN+1]\n\n\n\nuniqueSamples<-unique(count2[,list(seasonConsec,yearConsec)])\nfillIn5 <- cbind(uniqueSamples[rep(1:nrow(uniqueSamples),nRivers+1)],\n                 riverN=rep(1:(nRivers+1),each=nrow(uniqueSamples)),\n                 key=c(\"riverN\",\"yearConsec\",\"seasonConsec\")) \n\nsetkey(count2,riverN,yearConsec,seasonConsec)\ncount2<-count2[fillIn5]\ncount2[,countAdj:=scaleVec(count,na.rm=T),by=list(seasonConsec,riverN)]\ncount2[is.na(count),count:=0]\n#count2[riverN == 1, count:=as.numeric(rbinom(  sum((riverN == 1)),20,0.75 ))] \n# put in dummy numbers so don't get a sd of 0 calculated in bugs\ncount2[,year2:=yearConsec-min(yearConsec)+1]\n\ncountForN <- array(count2[,count],c(4,nYears,nRivers+1))\nmeanForN <- array(count2[,mean(count),\n                         by=list(riverN,seasonConsec)]$V1,\n                         c(4,nRivers+1)) #need to check indexing\nsdForN <- array(count2[,sd(count),\n                       by=list(riverN,seasonConsec)]$V1,c(4,nRivers+1)) \n#need to check indexing to see if it matches\n\nsdForN[sdForN == 0 ]  <- 1 # so we don't divide by 0\n\nstatsForN <- list(\n  countForN = countForN,\n  meanForN  = meanForN,\n  sdForN    = sdForN,\n  nYears    = nYears,\n  minYear   = min(count2$yearConsec),\n  maxYear   = max(count2$yearConsec)\n  \n) \n}\n\n##########################################################\n##############################################################################\n# output dMData  to species_DMData_river.RData\n############################################################################## \ndirectory <- tempfile( pattern=\"output-\", tmpdir =processedDir, fileext='-dMData')\ndir.create(directory)\nfile.copy(from='./makeDMData.R', to=paste(directory,'makeDMData.R',sep='/'))\nwriteLines(text=directory, con='./latest_directory')\nprint(directory)\n\nfileName <- paste('dMDataOut',\n                   species,\n                   subsetDMdataCohortMin,'_',\n                   subsetDMdataCohortMax,\n                   '.RData', sep='')\n\n#save.image(paste(directory,fileName, sep=''))\nif(modelType=='needToChangeThis'){\nsave(dMData, evalList, stdList, stdList_cohort, statsForN,\n     file = paste(directory,fileName, sep='/'))\nsave(dMData,evalList,stdList,stdList_cohort,statsForN,\n     file= file.path(processedDir,fileName))\nprint(str(dMData))\n}\n\nif(modelType=='js'){\n  save(dMData, evalList, d,\n       file = paste(\"~/westbrookJS\",fileName, sep='/'))\n  save(dMData,evalList,d,\n       file= file.path(processedDir,fileName))\n}\n\nassign('dMData',dMData,envir=.GlobalEnv)\nassign('evalList',evalList,envir=.GlobalEnv)\nassign('d',d,envir=.GlobalEnv)\n}\n##############################################################################\n##############################################################################\n# end of data prep\n##############################################################################\n##############################################################################",
    "created" : 1430760344168.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2917429523",
    "id" : "454BD442",
    "lastKnownWriteTime" : 1430918787,
    "path" : "C:/Users/Evan/Desktop/Conte/makeDMData/data_prep/dMDataFunctionFromDB.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}